图传重构需求（提示词）

目标：完全重构图像传输与显示流程——不再支持 RAW 原始数据，只支持 JPEG（硬件/软件解码）与 LZ4 压缩帧流。解码工作独立任务运行，数据通过消息队列安全传输到显示模块，使用 PSRAM 分配缓冲，多重缓冲保证传输效率。显示回调刷新，不滚动界面，UI 区域固定 240×180。

一、总体要求（必须遵守）

删除所有 RAW（未压缩原始）图像处理代码与路径（彻底移除，不仅是注释）。

JPEG 解码任务：专门任务负责接收 JPEG 数据流并解码。解码后直接输出 RGB565LE（16-bit little-endian）。

LZ4 解码任务：专门任务负责 LZ4 解压。解压后数据为 RGB565（大端/小端不确定时假设当前为BE），必须转换为 RGB565LE（低字节优先），然后推入显示缓冲。

任务并行：JPEG 解码和 LZ4 解码分别由独立任务（FreeRTOS task）运行，不在串行路径上阻塞网络接收。

消息队列：单向消息队列用于任务间传数据或 buffer 指针，长度＝4 条（最多排 4 帧），消息体为结构体（见下）。所有消息队列的传输必须是线程安全（FreeRTOS queue）。

TCP 缓冲区：TCP socket 发送/接收缓冲区设为 128 KB（SO_RCVBUF / SO_SNDBUF / LwIP 配置），并在套接字创建处显式设置。

显示刷新：采用 回调刷新（camera/network → push buffer → 回调触发 LVGL 刷新），但在显示层做缓冲取帧以避免直接在 ISR/网络回调内调用 LVGL。

多重缓冲：至少 3 帧缓冲（环形） 用于生产/消费（接收 → 解码 → 显示），缓冲分配在 PSRAM（malloc_caps 或 heap_caps），并保证对齐。

阻塞策略：在图像传输活跃时使用非阻塞或带超时的队列/套接字调用；仅在静止或初始化阶段允许短时间阻塞相关代码。

UI 区域：固定显示区域 240 × 180（像素）。所有传输来的图像尺寸 ≤ 240×180；若图像尺寸小于 240×180，必须按居中或按需填充黑边并禁止滚动和滚动条。

内存分配：所有帧缓冲、解码临时区和大型数组必须分配在 PSRAM（例如 heap_caps_malloc(size, MALLOC_CAP_SPIRAM)）；小对象/控制结构可放在 IRAM/DRAM。

LVGL 集成：显示回调需安全调用 LVGL API（遵守 LVGL 的线程模型：在 LVGL 任务/定时器上下文或用 lv_timer/事件投递机制更新图片）。不允许在网络回调或解码任务直接操作 LVGL 对象。

像素格式：最终显示缓冲 必须 为 RGB565LE（低字节在前）。LVGL 配置若为 LV_COLOR_DEPTH == 16，则直接把缓冲区指给 LVGL 图像对象（避免逐像素转换和 memcpy）。

静态行为：当没有新帧时，显示层显示最后一帧；不自动释放/重置画面；当发生内存不足或队列满时，丢弃最旧或最新帧的策略需明确（见“错误处理”）。

二、数据结构（建议）
// 消息队列中传递的消息结构（示例）
typedef enum {
    FRAME_TYPE_JPEG,
    FRAME_TYPE_LZ4, // LZ4 解压后仍需转换为 RGB565LE
} frame_type_t;

typedef struct {
    uint32_t MagicNumber;
    frame_type_t type;
    uint8_t width;      // <= 240
    uint8_t height;     // <= 180
    uint32_t payload_len; // bytes valid in buffer_ptr
    void *buffer_ptr;    // 指向 PSRAM 中的帧缓冲（RGB565LE），或指向压缩数据（若解码任务需要）
} frame_msg_t;

队列长度：4 条。

注意：消息只传递指针与元信息，不拷贝大数据（避免二次 memcpy）。接收端负责在处理完毕后释放/回收 buffer 指针到缓冲池。

三、缓冲池与内存分配

缓冲池大小与数量：最小 3 个帧缓冲（建议 4–6，根据 PSRAM 大小调整）。每缓冲大小按 240×180×2 = 86,400 bytes（RGB565）向上对齐页（例如 88KB/90KB）。

总 PSRAM 预算示例：6 * 88KB ≈ 528KB（帧缓冲） + 128KB TCP buffer + 解码临时内存（例如 JPEG 解码器需要的 scratch） → 总计约 1.0–1.5MB，按实际 PSRAM 大小调整。

分配方法（ESP-IDF）：heap_caps_malloc(size, MALLOC_CAP_SPIRAM | MALLOC_CAP_8BIT) 或 ps_malloc（如有）。确保可用并检测失败。

对齐：做到 32 字节或 DMA 对齐（便于 SPI/DMA 传输和 LCD DMA）。

内存释放：缓冲通过环形池管理，解码后 push 到消息队列；消费端（显示）处理完后把缓冲返回池。

四、任务与优先级（建议）

NetRecvTask（网络接收）

优先级：中等（e.g. tskIDLE_PRIORITY + 3）

功能：从 TCP socket 读取原始压缩包（JPEG 或 LZ4 payload），分配压缩数据 buffer，打包 frame_msg_t 发送到解码队列或直接放到解码任务的输入队列（解码任务独立）。

要点：设置 socket recv timeout（非阻塞或小超时），接收后立即 push 到对应的解码队列或等待缓冲可用。

JPEGDecodeTask

优先级：高（e.g. +4）

功能：从 JPEG 解码队列拿到压缩数据，解码到帧缓冲（直接 RGB565LE），push frame_msg_t 到 DisplayQueue。解码完成立即释放 JPEG 压缩 buffer（或回收）。

要点：使用硬/快速软件解码器，尽量减少临时内存。解码结果必须是 RGB565LE。

LZ4DecodeTask

优先级：高（与 JPEGDecodeTask 同级）

功能：拿 LZ4 压缩数据，解压到临时缓冲（PSRAM），将结果转换为 RGB565LE（必要时交换字节），然后 push 到 DisplayQueue。

要点：解压后直接写入目标帧缓冲（避免二次复制）；字节序转换尽量使用批量操作（32/64-bit swap），提高速度。

DisplayTask（LVGL）

优先级：中等或专用（LVGL 要求）

功能：从 DisplayQueue（长度4）获取 frame_msg_t，把缓冲指针提交给 LVGL 的图像对象。使用回调机制触发 LVGL 在合适上下文刷新画面（或将指针设置到 lv_img 数据并调用 lv_obj_invalidate() / timer）。

要点：不要在此任务内阻塞很长时间；保证 LVGL API 在安全上下文调用（在 LVGL 的线程/定时器环境中执行实际刷新）。

五、消息与队列策略

队列配置：

xQueueCreate(4, sizeof(frame_msg_t)); 用于 DisplayQueue。

溢出策略：当队列满时，丢弃最旧帧（FIFO）或拒绝新帧——在代码注释中指定明确策略（建议丢弃最旧，这样显示总是最新画面）。

超时：所有 xQueueSend/xQueueReceive 使用短超时（例如 10–50 ms），不是永久阻塞，除非在初始化/静止阶段允许阻塞。

优先级协作：解码任务在 push DisplayQueue 时如果队列满，可尝试释放最旧帧（消费模式）或短等待再重试。

六、TCP 缓冲设置（示例代码片段）
int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
int buf_size = 128 * 1024; // 128KB
setsockopt(sock, SOL_SOCKET, SO_RCVBUF, &buf_size, sizeof(buf_size));
setsockopt(sock, SOL_SOCKET, SO_SNDBUF, &buf_size, sizeof(buf_size));
// 根据 LwIP/IDF 版本，还需在 sdkconfig/lwipopts.h 中同步增大 TCP_WND、PBUF_POOL 等


同时在 sdkconfig 或 lwipopts.h 中调大 TCP_WND、TCP_SND_BUF、PBUF_POOL_SIZE 等，以匹配 128KB 的 socket 缓冲。

七、显示回调与 LVGL 集成

回调方式：DisplayTask 将新的帧缓冲指针推送给 LVGL-safe 回调函数（例如通过 lv_async_call() 或 lv_timer），不要在网络/解码任务中直接调用 lv_img_set_src()。

缓冲提交示例：

解码任务 push frame_msg_t 到 DisplayQueue。

DisplayTask 从队列取出 frame_msg_t，调用 lv_async_call(display_update_cb, frame_msg_t) 或在 LVGL 线程通过 xQueueSendToFront(lvgl_queue, &frame_msg_t, 0) 处理。

在 display_update_cb 中，仅将 lv_img 的 src 指向该缓冲（无需 memcpy），然后 lv_obj_invalidate(img_obj)。

注意：确保 lv_img 的 src 指针生命周期至少在 LVGL 渲染完成前有效（直到下一帧替换时再释放）。

八、尺寸适配与 UI 规范

UI 区域固定：240 × 180，禁止滚动条与滚动动作（关闭滚动容器/指针）。

图像小于显示区域：按居中显示并用黑色填充四周（或按配置居左/居中/缩放，默认居中）。

图像等比缩放：若实现缩放，必须在解码任务后在缓冲层做一次缩放（避免 LVGL 做逐像素缩放造成 CPU 占用），优先使用整点/快速缩放。

UI 操作：UI 不允许拖动画面或弹出滚动条，仅支持查看（单张图显示）；若需要放大/缩小功能单独实现按键/菜单控制。

九、错误处理与监控

内存不足：若 heap_caps_malloc() 返回 NULL，应记录错误并尝试回收最旧帧；不要重入无限循环阻塞。

队列满：打印日志并按溢出策略处理（丢弃最旧或拒绝新帧）。

网络异常：TCP 连接断开时释放所有未消费缓冲并清空队列；重连期间可显示占位图。

监控项：帧率、队列深度、PSRAM 可用内存、LVGL 渲染耗时、网络吞吐（KB/s）。定期输出到串口或通过 web/HTTP 接口上报。

十、验收标准（可被自动/人工测试）

功能正确

不再包含 RAW 路径（源码中无 RAW 解码/显示分支）。

JPEG 解码帧直接为 RGB565LE，并能被 LVGL 正确显示（颜色正常）。

LZ4 解码后数据被正确转换为 RGB565LE 并显示。

性能

当传输 240×180、单帧约 37 KB 时，系统至少能稳定 30 FPS ±10%（在良好 Wi-Fi 与 STA-only 情况下），或在较差环境下不得低于 10 FPS（取决于无线环境）。

队列长度 4 生效；短时间内发送 5 帧时不会崩溃 / 内存泄漏。

资源与稳定性

所有帧缓冲分配在 PSRAM（检查 malloc caps）。

TCP buffer 为 128KB（检查 sockopt 或 lwip 配置）。

无内存泄漏（valgrind/heap tracing），稳定运行 1 小时以上无崩溃。

UI 行为

显示区域固定 240×180，图像小于区域时居中显示，且无滚动条或滚动行为。

错误处理

队列满、PSRAM 分配失败和网络中断都能优雅处理（日志 + 重试/回收策略）。